// jhcSceneVis.h : interface to ELI visual behavior kernel for ALIA system
//
// Written by Jonathan H. Connell, jconnell@alum.mit.edu
//
///////////////////////////////////////////////////////////////////////////
//
// Copyright 2020-2024 Etaoin Systems
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
///////////////////////////////////////////////////////////////////////////

#pragma once

#include "jhcGlobal.h"

#include "Geometry/jhcMatrix.h"        // common robot
#include "RWI/jhcEliRWI.h"              

#include "Kernel/jhcStdKern.h"         


//= Interface to ELI visual behavior kernel for ALIA system.
// Basic calls answer various questions about current scene.
// -----------------------------------------------------------------
// 
// VIS_VALUE:    "What size is X?"
// 
// can ask about several different range values using names:
// 
//   distance size length width thickness height
// 
// can also query category using related value: "How tall is X?"
// results come back as qualitative values, like for size:
// 
//   very small, small, medium small, big, very big
// 
// -----------------------------------------------------------------
// 
// VIS_VAL_OK:   "Is X very narrow?"
// 
// can ask about the truth or falsity of any of the range values
// result comes back as an echo of the query, possibly negated
//
// -----------------------------------------------------------------
// 
// VIS_COLOR:    "What color is X?"
// 
// result comes back as one or more assertions about values:
// 
//   red orange yellow green blue purple black gray white
//  
// does not necessarily give only dominant color, many objects are mixed
// but guarantees a minimum fraction of pixels have that color
// 
// -----------------------------------------------------------------
// 
// VIS_COL_OK:   "Is X red?"
// 
// can ask about the truth or falsity of any of the range values
// result comes back as an echo of the query, possibly negated
// if object has multiple colors, the modifier "partly" is added
// 
// -----------------------------------------------------------------
// 
// VIS_POSITION: "Where is X?"
// 
// tries to locate query object relative to some other known object
// result is an assertion like: "X is to the left of Y"
// often cannot be very specific, fails if no other objects discussed
// 
// -----------------------------------------------------------------
// 
// VIS_POS_OK:   "Is X between Y and Z?"
// 
// can ask about the truth or falsity of a few spatial relations:
// 
//   between, left of, right of, in front of, behind, near, next to 
// 
// result comes back as an echo of the query, possibly negated
// 
// -----------------------------------------------------------------
// 
// VIS_COMP_OK:  "Is X taller than Y?"
// 
// can compare query object to something else using some property
// range comparatives contain a direction like "closer" vs "farther"
// color comparatives only ask about degree of color like "redder"
// result comes back as an echo of the query, possibly negated
// 
// -----------------------------------------------------------------
// 
// VIS_SUBIT:    "How many X are there?"
// 
// automatically applies unstated restrictions to selecting items
// these include range values, colors, location, and comparatives:
// "How many medium tall red things behind the biggest thing do you see?"
// result comes back as an echo of query with a new count predicate
// 
// -----------------------------------------------------------------
// 
// VIS_ENUM:     "Find X"
// 
// automatically applies unstated restrictions to selecting items
// can use special superlatives on selection group to pick one:
// 
//   middle leftmost righmost
// 
// can also use range value and color superlatives like: "biggest", "whitest"
// result comes back as an echo of the query with an additional "visible"
// returns a new candidate on each call until all possibilies reported
// works with graphizer to allow existence queries: "Is there a blue thing?"
// 
// -----------------------------------------------------------------
//
// VIS_GAZE:     "Look at X"
// 
// steers neck servos to place object in center of Kinect view
// assumes object X is already bound by some other description
// 
// -----------------------------------------------------------------
// NOTE: many rules needed for this kernel can be generated by jhcNetBuild::AutoVals

class jhcSceneVis : public jhcStdKern
{
// PRIVATE MEMBER VARIABLES
private:
  // terminology
  static const char * const rng[], * const rng0[], * const rng1[];
  static const char * const col[], * const loc[],  * const sloc[];

  // instance control variables
  jhcMatrix *cpos, *cdir; 

  // link to hardware 
  jhcEliRWI *rwi;           // likely shared
  jhcSurfObjs *sobj;
  jhcEliBody *body;

  // status variables
  jhcAliaNote *rpt;          // where to inject NOTEs
  int some, close;

  // analysis mask
  jhcImg bin;


// PRIVATE MEMBER PARAMETERS
private:
  // distance category parameters
  double dist0, dist1, dist2, dist3, dvar, drop, xbd, ybd;

  // object shape categories
  double len0, len1, len2, len3, thk0, thk1, thk2, thk3;

  // object dimension categories
  double sz1, sz2, wid1, wid2, ht1, ht2;

  // comparison and location parameters
  double rdom, cdom, tween, sdev, buddy, hood, flr;
  int cmax;


// PUBLIC MEMBER VARIABLES
public:  
  jhcParam rps, sps, dps, cps;
  int gok;                   // whether succeeds without body
  int dbg;                   // control of diagnostic messages


// PUBLIC MEMBER FUNCTIONS
public:
  // creation and initialization
  ~jhcSceneVis ();
  jhcSceneVis ();

  // processing parameter bundles 
  int Defaults (const char *fname =NULL);
  int SaveVals (const char *fname) const;


// PRIVATE MEMBER FUNCTIONS
private:
  // processing parameters
  int rng_params (const char *fname);  
  int shape_params (const char *fname);  
  int dims_params (const char *fname);  
  int comp_params (const char *fname);  

  // overridden virtuals
  void local_platform (void *soma);
  void local_reset (jhcAliaNote& top);
  void local_volunteer ();
  int local_start (const jhcAliaDesc& desc, int i);
  int local_status (const jhcAliaDesc& desc, int i);

  // event functions
  void update_objs ();
  int in_view (int t) const;
  void mark_gone (int id);
  void alert_any ();
  void alert_close ();
  void mark_attn ();
               
  // gaze control
  JCMD_DEF(vis_look);
  JCMD_DEF(vis_orient);
  int chk_stuck (int i, double err);

  // value ranges
  JCMD_DEF(vis_value);
  int net2rng (const jhcAliaDesc *hq) const;
  JCMD_DEF(vis_val_ok);
  int net2des (int& cat, const jhcAliaDesc *p) const;

  // color
  JCMD_DEF(vis_color);
  JCMD_DEF(vis_col_ok);
  int txt2cnum (const char *txt) const;

  // spatial location
  JCMD_DEF(vis_position);
  JCMD_DEF(vis_pos_ok);
  int txt2pos (const char *txt) const;

  // property comparisons
  JCMD_DEF(vis_comp_ok);
  int txt2comp (const char *txt) const;

  // object counting 
  JCMD_DEF(vis_subit);

  // object finding
  JCMD_DEF(vis_enum);
  int pref_prop (int props[]) const;
  bool already (int i, int t) const;
  void record (int i, int t);
  int pick_num () const;
  int pick_mid () const;
  void cache_color (int pref, int props[]);
  int pick_best (int pref, int r, int r2) const;

  // track testing
  int suitable (int props[], int t, int r, int r2) const;
  int rng_test (int props[], int t, int r) const;
  int loc_test (int props[], int t, int r, int r2) const;
  int col_test (int props[], int t, int r) const;

  // track properties 
  int trk2rng (int cat, int t) const;
  int trk2rcomp (int cat, int t, int r) const;
  double rng_val (int cat, int t) const;
  int quantize (double v0, double v1, double v2, double v3, double val) const;
  int trk2loc (int cat, int t, int r, int r2) const;
  int near_to (int t, int r) const;
  int side_of (int t, int r) const;
  int twixt (int t, int r, int r2) const;  
  int trk2ccomp (int cat, int t, int r) const;
  double pref_val (int cat, int t, int r, int r2) const;

  // net properties
  int obj_specs (int props[], jhcAliaDesc **ref, jhcAliaDesc **ref2, const jhcAliaDesc *obj) const;
  int net2val (const jhcAliaDesc *fcn, int cat) const;
  int net2col (const jhcAliaDesc *obj, int cnum) const;
  int net2pos (jhcAliaDesc **ref, jhcAliaDesc **ref2, const jhcAliaDesc *obj, int cat) const;
  int net2comp (jhcAliaDesc **ref, const jhcAliaDesc *obj, int cat) const;
  int net2super (const jhcAliaDesc *obj) const;
  int cvt_refs (int& r, int& r2, const jhcAliaDesc *ref, const jhcAliaDesc *ref2) const;
  int node2trk (const jhcAliaDesc *n) const 
    {return sobj->ObjTrack(rpt->VisID(n, 0));}

  // net assertions
  jhcAliaDesc *obj_node (int t, int& born);
  void std_props (jhcAliaDesc *obj, int born);
  void prop2net (jhcAliaDesc *obj, int props[], jhcAliaDesc *ref, jhcAliaDesc *ref2);
  void rng2net (jhcAliaDesc *obj, int cat, int val);
  void des2net (jhcAliaDesc *obj, int cat, int des, int val);
  void super2net (jhcAliaDesc *obj, int sel) const;
  jhcAliaDesc *trk2node (int t) const       
    {return rpt->NodeFor(sobj->ObjID(t), 0);}

  // semantic messages
  int err_neck ();
  int err_miss (jhcAliaDesc *obj);

  // debugging
  const char *cat2txt (int cat) const;
  void prop_vect (int *props) const;

};

